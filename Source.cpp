#include<iostream>
#include<map>
#include<set>
#include<ctime>
#include<vector>
using namespace std;

//Функция для вывода последовательности на экран
void show_map(map<int,int>map)
{
	for (auto it = map.begin(); it != map.end(); it++)
	{
		cout << "(" << it->first << "," << it->second << ")" << '\t';
	}
	cout << endl;
}

int main()
{
	// Входные параметры
	int n = 3;
	cout << "n" << " = " << n << "\n";
	map<int, int> mymap = { {1,10},{2,11},{3,11},{4,11},{5,11},{6,10},{7,11}, {8,11},{9,11},{10,11},{11,11},{12,11},{13,11},{14,10}};

	// Вывод на экран исходной последовательности
	show_map(mymap);

	//Переносим ключи в вектор 
	vector<int>keys;
	for (auto it = mymap.begin(); it != mymap.end(); it++) { keys.push_back(it->first);}

	//Искусственно добавляем элемент, это необходимо для случая когда последний элемент включен в подпоследовательность. Таким образом последний элемент пройдет условия* ниже
	keys.push_back((--mymap.end())->first+1);

	//Создаем контейнер set для накапливания элементов подпоследовательности
	set<int>s_filter;

	//Цикл, перебирающий ключи 
	for (int i=1;i<keys.size();i++)
	{
		   // При равентве значений двух соседних ключей-> Присваивам контейнеру ключей ключи одинакового значения
			if ((mymap.count(keys[i])!=0)&&(mymap[keys[i - 1]] == mymap[keys[i]]))
			{
				//Таким образом накапливаем подпоследовательность
				s_filter.insert(keys[i]);
				s_filter.insert(keys[i-1]);
			}
			//Проверяем контейнер ключей на пустоту, чтобы исключить случай, при котором каждое значение уникально и подпоследовательностей не существует.
			else if (s_filter.size() != 0)
			{
				//Переносим контейнер из ключей в вектор, для того чтобы можно было работать с расположением элементов в подпоследовательности  
				vector<int> v_filter(s_filter.begin(), s_filter.end());

				//Цикл для подпоследовательности
				for (int j = 0; j < v_filter.size(); j++)
				{
					//Условия при которых мы должны удалить ключ подпоследовательности
					if ((j != 0) && (j != (v_filter.size() - 1)) && ((j + 1) % n != 0))
					{
						//Удаление элемента из последовательности с искомым ключом 
						mymap.erase(v_filter[j]);
					}
				}

				// Очищение контейнера для работы с новой подпоследовательностью
				s_filter.clear();
			}
		}
	// Вывод на экран обработанной последовательности
	show_map(mymap);

	system("pause");
	return 0;
	}






